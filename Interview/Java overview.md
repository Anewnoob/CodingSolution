### 1. 基本概念
   1. **Java程序初始化顺序**
      1. **对象变量初始化遵循3个原则**
         1. 静态优先于非静态；
         2. 父类优先于子类；
         3. 按照成员变量的顺序初始化，散布于方法定义内会在方法调用前初始化；
      2. **加载顺序** （同级内加载顺序按照代码顺序）
         1. 父类的静态变量、静态语句块
         2. 子类静态变量、静态语句块
         3. 父类实例变量、普通语句块
         4. 父类构造函数
         5. 子类实例变量、普通语句块
         6. 子类构造函数
   2. **Java和C++区别**

      |            | Java                       | C++               |
      | ---------- | -------------------------- | ----------------- |
      | 面向对象   | 纯粹面向对象               | 面向过程+面向对象 |
      | 跨平台     | 通过虚拟机实现跨平台特性   | 依赖于特定平台    |
      | 指针       | 无，引用是安全指针         | 有                |
      | 垃圾回收   | 自动回收                   | 手动回收          |
      | 多重继承   | 不支持（为了防止歧义情况） | 支持              |
      | 操作符重载 | 不支持                     | 支持              |
      | 线程       | 内置支持                   | 依靠第三方库      |
      | goto       | 保留字但不可用             | 可用              |
      | 条件编译   | 不支持                     | 支持              |

   3. **反射**
      1. 提供以下功能（重点是在运行时，而不是编译期）：
         1. 在运行时，判断任意一个对象所属的类；
         2. 在运行时，构造任何一个类的对象；
         3. 在运行时，判断任何一个类所拥有的成员变量和方法（通过反射甚至可以调用private方法）；
         4. 在运行时，调用任意一个对象的方法。
      2. 反射最重要的用途是开发各种通用框架。
   4. **注解(Annontation)**
      1. java.lang包下存在重点3种注解:
         1. @Override重写注解；
         2. @Deprecated过时注解；（某些方法被认为设计的不好，但为了向下兼容，不能直接抛弃，就把它设置为过时，可以看到横杠的方法就是过时的）。
         3. @SuppressWarnings抑制编译器警告注解。
      2. **自定义注解类编写规则**
         1. 所有注解自动继承java.lang.Annotation接口，并且不能结成其他类或接口；
         2. 参数成员只能public或default修饰符；
         3. 要获取类方法和字段的注解信息，必须通过Java反射技术，无其他方法；
   5. **泛型**
      1. **泛型方法**
         1. 可以在调用时接收不同类型的参数，<T>；
         2. 类型参数只能代表引用型类型，不能是原始类型（例如int, double, char等）；
      2. **泛型类**
      3. **类型通配符**：List<?>，逻辑上是List<String>等所有具体类型的父类；
   6. **字节与字符**
      1. 字符：抽象意义上的一个符号，例如`'1','a','%'`等；
      2. 字节，计算机存储数据的单元，8位二进制数，例如`0x01, 0x45, 0xFA`等；

      | 类型    | 英文字符 | 中文字符 |
      | ------- | -------- | -------- |
      | ASCII   | 1 byte   | 2 byte   |
      | UTF-8   | 1 byte   | 3 byte   |
      | Unicode | 2 byte   | 2 byte   |
      | UTF-16  | 2 byte   | 2 byte   |
      | UTF-32  | 4 byte   | 4 byte   |

   7. **访问修饰符**
   
      | 修饰符    | 当前类 | 同包 | 子类 | 其他包 |
      | --------- | ------ | ---- | ---- | ------ |
      | public    | 是     | 是   | 是   | 是     |
      | protected | 是     | 是   | 是   | 否     |
      | default   | 是     | 是   | 否   | 否     |
      | private   | 是     | 否   | 否   | 否     |

   8. **深拷贝与浅拷贝**
      1. 浅拷贝：只复制目标对象，但不复制目标对象引用的对象；
      2. 深拷贝：对基本数据进行值传递，对于引用数据创建一个新的对象并复制其内容
   9. **lamda表达式**
      1. 主要用于定义行内执行的方法类型接口，例如一个简单方法接口；
      2. 免去了使用匿名方法的麻烦，给Java简单强大的函数化编程能力。
   10. **变量作用域**
   11. **字符串常量池**
       1. JVM为了减少字符串对象的重复创建，维护了一个特殊的内存，被称为字符串常量池；
       2. `String s1 = "abc"`出现字面量形式创建字符串对象时，JVM首先会检查常量池中是否存在相同内容的字符串对象引用，若没有才会创建新的对象。
       3. `String s1 = new String()`new出来的对象不会放在常量池中，内存地址是不同的。
   12. **解释型语言和编译型语言**
       1. 将高级语言翻译成计算机语言有解释和编译两种方式，区别只是翻译的时间不同。
       2. 编译型语言：在程序执行之前，需要借助一个程序将高级语言翻译成计算机语言，然后计算机就能直接执行它了；
       3. 解释型语言：不需要编译，节省了一道工序，在程序运行的过程中翻译，每条语句都在执行时候才翻译。
           1. 脚本语言：解释型语言的一种。不需要编译，由解释器负责解释。脚本语言一般都以文本形式存在，类似一种命令。
       4. 通俗理解：编译型语言像做一桌菜吃，解释型语言像吃火锅边煮边吃。

### 2. **面向对象**
   1. **Java四个基本特性：** 抽象性、封装性、继承性、多态性。
   2. **多态性**
      1. 方法重载：同名方法存在不同的参数列表，体现编译时的多态性；
      2. 方法重写：子类对父类的方法重新实现，体现运行时的多态性。
   3. **内部类**
      1. 成员内部类：作为外围类的一个成员，可以无限制访问外围类的成员和方法；但外围类访问内部类需要通过实例访问。
      2. 静态内部类：创建不需要依赖于外围类；不能使用任何外围类的非static成员变量和方法。
      3. 局部内部类：定义在方法或作用域内，应用于比较复杂的问题，需要创建一个类来辅助解决，但又不希望这个类是公用的。
      4. 匿名内部类：必须继承一个父类或实现一个接口，实例化原父类或接口并直接在`{}`内实现方法。最常用的情况是在多线程的实现上。
   4. **组合继承代理区别**
      1. 组合：在总类中实例化各个部分类，以达到组合效果；
      2. 继承：子类需要具有父类的功能，各个子类有所差异；
      3. 代理：用于只需部分暴露某类的功能。创建代理类，在代理类new一个原类对象，添加需要暴露的原类功能。
   5. **构造函数**
      1. 函数的一种特殊形式，不需要定义返回类型，名称和类名完全一致，可以重载；
      2. 一般用于初始化一些成员变量，生成一个类的实例时会调用构造函数；
      3. 如果不声明构造函数，会自动生成一个默认的不带参数的空构造函数；
      4. 构造函数的作用：
         1. 创建对象：对象的创建必须有构造函数；
         2. 对象初始化：针对不同的参数列表给与之符合的对象初始化。
   6. **向上造型和向下造型**
      1. 向上造型：父类引用指向子类的对象，例如`Father f1 = new Son()；`
      2. 向下造型：把指向子类对象的父类引用赋给子类引用，需要强制转换，例如`Son s1 = (Son)f1;`

### 3. **关键字**
   1. **final/static**
      1. final：变量值无法被修改；声明类不可被继承。
      2. static：
         1. 静态变量：只在内存中存在一份，可以通过类名直接访问，所有实例共享一个静态变量；
         2. 静态方法：类加载时就存在了，不依赖于任何实例，因此静态方法必须有实现不能为abstract；
         3. 静态语句块：类初始化时运行一次；
         4. 静态内部类：创建不需要依赖外部类，不能访问外部类的非静态变量和方法；
         5. 静态导包：使用静态变量和方法时不用指明ClassName，从而简化代码，但可读性大大降低；
   2. **break/continue/return**
      1. break跳出一层循环；
      2. continue终止当前循环操作，继续根据循环条件执行循环。
      3. return
         1. 从当前方法中退出，返回到调用该方法的位置；
         2. 返回一个与方法数据类型对应的值；
         3. return后也可不带参数（包括void方法中也可用），单纯用于跳出方法。
   3. **final/finally/finalize**
      1. final：表示属性不可变、方法不可重写（仍可被子类使用）、类不可被继承。
      2. finally：在异常处理时，用于执行任何的清除操作。catch执行完会进入finally，最后return。常用于数据库连接关闭操作上。
      3. finalize()：是Object中的方法，垃圾回收器将要回收对象内存前被调用，即被JVM宣告死亡时会先调用此方法，让对象处理它生前的最后事情（可以趁此机会挣脱死亡命运）。
         1. 判定死亡：Java采用可达性分析判定一个对象是否该死，Java以一系列GC Roots对象为起点，如果一个对象的引用链最终可以追溯到GC Roots，则平安无事。
         2. 最后救赎：
            1. 对象覆写了finalize()方法，在被判死后自我救赎；
            2. 在finalize()方法执行过程中，重新引用到GC Roots链上（例如把当前对象引用this赋值给某对象的成员变量，重新建立可达引用）。
         3. finalize()作用：被认为用作最后资源的回收，但不确定性大、运行代价高，因此在回收资源中表现不佳。因此并没有什么用（是Java诞生时为了使C++程序员更容易接受它而做的妥协）。
   4. **assert**
      1. 检查控制流
      2. 检查输入参数是否有效
      3. 检查函数结果是否有效
      4. 检查程序不变
   5. **volatile**
      1. 是一个类型修饰符，设计用来修饰被不同线程访问和修改的变量。
      2. 使用volatile修饰后，所有线程在任何时间所看到的变量值相同。
      3. volatile会降低程序执行效率，尽量不要使用。
   6. **instanceof**
      1. 是一个二元操作符，类似`>, <, ==`；
      2. 是Java保留关键字，用于测试左边的对象是否是右边类的实例，返回`boolean`数据类型。
   7. **strictfp**
      1. 可应用于类、接口、方法；
      2. 该方法、类中所有的float和double表达式都严格遵守FP-strict的限制，符合IEEE-754规范；
      3. 若想让浮点运算更精确，且不会因为不同的硬件平台执行不同，可以使用。
   8. **transient**
      1. 一个对象只要实现了Serilizable接口，这个对象就可以被序列化，这个序列化模式为开发者提供了很多便利；
      2. 在不需要序列化的属性前加入transient关键字，序列化对象时，此属性就不会被序列化到指定目的地中。
      3. 常用于敏感信息，例如银行密码等，我们不希望在网络操作中传输这些信息，就在这些变量上加入transient关键字。
   9. **native**
      1.  解决某一个问题，往往喜欢单单这个语言来写；
      2.  JNI(Java Native Interface)Java本地接口，是Java平台有个用户和本地C代码进行互操作的API。

### 4. **基本数据类型与运算**
   1. **Java基本数据类型和引用类型，自动装箱拆箱**

      | 类型    | 包装类    | 默认值       | 存储 | 取值范围      |
      | ------- | --------- | ------------ | ---- | ------------- |
      | 整数型  |           |              |      |               |
      | byte    | Byte      | (byte)0      | 8    | -2^7-2^7-1    |
      | short   | Short     | (short)0     | 16   | -2^15-2^15-1  |
      | int     | Integer   | 0            | 32   | -2^31-2^31-1  |
      | long    | Long      | 0L           | 64   | -2^63 - 2^63  |
      | 浮点型  |           |              |      |               |
      | float   | Float     | 0.0f         | 32   |               |
      | double  | Double    | 0.0d         | 64   |               |
      | 布尔型  |           |              |      |               |
      | bollean | Bollean   | false        | 1    | true / false  |
      | 字符型  |           |              |      |               |
      | char    | Character | \u0000(null) | 16   | 存储Unicode码 |

      jdk1.4后实现了自动拆装箱的功能:
      ```java
      // > jdk 1.4
      public class TestDemo {
          public static void main(String[] args) {
              Integer m = 10; // 自动装箱
              int i = m; // 自动拆箱
          }
      }
      ``` 
      ```java
      // jdk 1.4
      public class TestDemo {
          public static void main(String[] args) {
              Integer b = new Integer(210);
              int c = b.intValue();
          }
      }
      ``` 
   2. **valueOf缓存池**
      1. new Integer(123)会创建新的对象，而Integer.valueOf(123)可能会使用缓存对象；
      2. 编译器在自动装箱过程中调用valueOf()方法，多个Integer实例值相同时，会引用相同对象；
      3. Java 8中，Integer缓存值大小默认为-128~127。
      4. Java还将以下基本类型值放在缓冲池中，包含：
         1. bollean true and false；
         2. all byte values；
         3. short values between -128~127；
         4. char in the range \u0000 to \u007F.
      ```java
      Integer m = 123;
      Integer n = 123;
      System.out.println(m == n); // true
      ```
   3. **i++与++i的区别**
      1. i++是在此行程序执行完毕后自增，++i是在此行程序执行之前自增。
      2. i++三步操作：栈中取出i，i自增1，将i存到栈；
      3. ++i和i++都不是原子操作，原子操作指多线程在一起执行时，一个操作一旦开始就不会被其他线程打断。
   4. **位运算符**

      | 操作符 | 名称       | 描述                                       | 例子 |
      | ------ | ---------- | ------------------------------------------ | ---- |
      | &      | 与and      |                                            |      |
      | `|`    | 或or       |                                            |      |
      | ~      | 非not      |                                            |      |
      | ^      | 异或xor    |                                            |      |
      | <<     | 左移       | 符号位保持不变，左移1位乘以2               |      |
      | >>     | 右移       | 符号位保持不变，高位补符号位，右移1位除以2 |      |
      | >>>    | 无符号右移 | 包括符号位按位右移，高位补0                |      |
   5. **原码、补码、反码**
      1. 机器数：一个数的二进制表示形式是机器数，最高位存放符号。+3(0000 0011)，-3(1000 0011);
      2. 真值：机器数对应的真正数值称为机器数真值，例如：0000 0001 = 1，1000 0001 = -1；
      3. 原码：8位二进制数取值范围[1111 1111, 0111 1111]，即[-127, 127]；
      4. 反码：正数反码是本身；负数反码是符号位不变，其余位取反；例如：[1000 0001]原 = [11111 1110]反
      5. 补码：正数补码是本身；负数补码是其反码+1；例如：[1000 0001]原 = [1111 1110]反 = [1111 1111]补；
   6. **不用额外变量交换两个整数**
      1. 异或法
         ```java
         a = a ^ b; // a, b不同位 置1，相同位 置0；
         b = a ^ b; // 对与一位x，0 ^ x = x, 1 ^ x = ~x，因此b相同位不变，不同位取反，即得到a，赋值给b；
         a = a ^ b; // 同上，由a（已赋给b）得到b的值，赋给a。
         ```
      2. 相加法
         ```java
         a = a + b
         b = a - b // b = a + b - b = a
         a = a - b // a = a + b - a = b
         ```
      3. &和&&，|和||的区别
         1. 都表示与和或；
         2. `&&`有熔断机制，即第一个条件不满足，后面条件就不再判断。
         3. `||`有熔断机制，即第一个条件已满足，后面条件就不再判断。

### 5. **字符串与数组**
   1. **String, StringBuffer, StringBuilder；String不变性**
   2. **String有重写Object的hashcode()和toString()吗？如果重写equals不重写hashcode会出现什么问题？**
      1. String重写了。当equals()被重写时，往往必须重写hashCode()，以维护hashCode的常规协定：
         1. object1.equeals(object2) => object1.hashCode() == object2.hashCode()
         2. ! object1.hashCode() == object2.hashCode() => ! object1.equals(object2)
         3. object1.hashCode() == object2.hashCode() 不一定 object1.equals(object2)，因为两个不同object可能存在相同hashcode
      2. 例如存储Set类时，如果object1.equeals(object2)，但没有对hashCode重写导致两个对象有不同hashcode，则Set中将会出现两个值相同的对象，导致错误。
      3. 如果定义一个类，包括学号、姓名、分数等，若想把这个对象作为key，需要重写equals()和hashCode()，以保证对象属性不变时，其hashCode不能改变。
   3. **字面量(literal)**
      1. 字面量指源代码中直接表示的一个固定值；
      2. 八进制在整数字面量前加`0`来表示；十六进制在整数字面量前加`0x`表示；Java 7新增二进制，在整数字面量前加`0b`表示。
      3. Java 7规定在数值字面量，无论是整数还是浮点数，都允许在数字之间插入任意多个下划线`_`，不会影响数值，目的是方便阅读。
      ```java
      public class BinaryIntegralLiteral {
          public static void main(String[] args) {
              System.out.println(0b010101); // 21
              System.out.println(0B010101); // 21
              System.out.println(0x15A); // 346
              System.out.println(0X15A); // 346
              System.out.println(077); // 63
              System.out.println(5_000); // 5000
          }
      }
      ```

### 6. **异常处理**
   1. **常见异常以及其基类**
      1. `Throwable`是Java语言中所有错误和异常的超类，有两个子类：`Error`, `Exception`。
      2. `Error`：错误，程序无法处理的，如OutOfMemoryError, ThreadDeath等，这种情况只能任由JVM处理，大部分情况下会选择直接终止线程。
      3. `Exception`：程序可以处理的异常。
         1. 受检异常(CheckException)：发生在编译阶段，必须使用try...catch...或throws，否则不能通过；
         2. 非受检异常(UncheckedException)：程序运行时的错误。
            1. 例如除以`0`会引发Arithmetic Exception，此时程序崩溃且无法恢复。
            2. 发生在运行期，具有不确定性，主要由程序逻辑引起、难以排查。因此在程序设计中要认真考虑，尽量处理异常。
      4. 常见异常基类：`IOException`, `RumtimeException`;

### 7. **Object类通用方法**
   ```java
   public final native Class<?> getClass()
   public native int hashCode()
   public boolean equals(Object obj)
   protected native Object clone() throws CloneNotSupportException
   public String toString()
   public final native void notify()
   public final native void notifyAll()
   public final native void wait(long timeout) throws InterruptedException
   public final void wait(long timeout, int nanos) throws InterruptedException
   public final void wait() throws InterruptedException
   protected void finalize() throws Throwable
   ```
   1. **equals()**
      1. equals()与==区别
         1. 对于基本类型，==判断两个值是否相等，无equals()；
         2. 对于引用类型，==判断两个实例是否引用同一个对象，equals()判断引用对象是否等价（是否值相同）。
      2. 等价关系
         1. 自反性：`x.equals(x) // true`
         2. 对称性：`x.equals(y) == y.equals(x) // true`
         3. 传递性：`x.euqals(y), y.equals(z)，则x.equals(z) // true`
         4. 一致性：多次调用equals()方法结果不变；
         5. 对任何非null对象x，`x.euqals(null) // false`
      3. 实现
         1. 检查是否为同一对象的引用，如果是返回true；
         2. 检查是否是同一个类型，如果不是返回false；
         3. 将Object实例进行转型；
         4. 判断每个关键域是否相等。
   2. **hashCode()**
      1. 返回散列值。等价的两个实例散列值一定相同，但不同的两个实例散列值也可能相同。
      2. 理想的散列函数应当具有均匀性，目前没有完美的hash算法可以完全避免哈希碰撞。
      3. 作用和意义：hashCode()用于在散列存储结构中确定对象的存储地址，用于提高容器查找和存储的快捷性，如HashSet, HashMap, HashTable等。
   3. **toString()**
      1. 默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。
   4. **clone()**
      1. 是protected方法，不是public，一个类不显示重写clone()，其他类就不能直接调用该类实例的clone()方法。