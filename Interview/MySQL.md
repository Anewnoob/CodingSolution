#### MySQL基础

1. **什么是事务？**
   1. 事务指的是满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback回滚。
   2. AUTOCOMMIT：MySQL采用自动提交模式。若不显式使用START_TRANSACTION开始一个事务，则每个查询都会被当作一个事务提交。
2. **数据库ACID**
   1. 原子性(atomcity)：每个事务都是不可分割的单位，事务中的操作要么全部成功，要么全部失败。
   2. 一致性(consistency)：事务必须使数据库从一个一致性状态变换到另一个一致性状态。例如A, B两账户存款总额2000元，无论A, B多少次转账，他们的存款总额仍然是2000元。
   3. 隔离性(isolation)：多个用户并发使用数据库时，数据库为每个用户开一个事务，事务之间相互隔离。
   4. 持久性(durability)：一旦事务提交，所做的修改将被永远保存到数据库。即使系统崩溃，操作结果也不能丢失。
3. **数据库范式**
   1. 最低要求是第一范式，在此基础上更多的要求组成第二范式，其余范式类推。一般数据库只需满足第三范式即可。
   2. 1NF：属性不可分；
      1. 每一列都是不可再分的属性值，确保每一列的原子性。
   3. 2NF：属性完全依赖于主键（消除部分子函数依赖）；
      1. 可以通过分解满足。例如：键码为Sno标号和Cname课程名称，Grade成绩完全依赖于Sno和Cname，即每个学生每门课程都有成绩，没有任何冗余数据。而学生的学院Sdept依赖于Sno，部分依赖于键码，因此当学生选多门课程时，Sdept数据将会重复出现。
      2. 解决方案是进行分解，分解为Sno_Cname_Grade和Sno_Sname_Sdept。
   4. 3NF：属性不依赖于其他非主属性（消除传递依赖）；
      1. 每个属性都和主键有直接关系而不是间接关系。例如`a -> b -> c`这样的是不符合第三范式的。
   5. 4NF：同一表内多对多关系删除；
   6. 5NF：从最终结构重新建立原始结构。
4. **并发一致性问题**
   1. 丢失修改
      1. T1和T2两个事务先后读到一个数据（值相同），T1先修改，T2再修改（基于原始值），最终T1修改操作丢失，等价于只有T2修改。
   2. 脏读
      1. 一个事务读取另外一个事务还没有提交的数据。若此事务回滚，那么一个事务看到的数据就是一笔脏数据。
   3. 不可重复读
      1. 是指在一个事务内，多次读同一数据，但返回了不同结果。例如，在一个事务内反复读同一数据，在此期间另一个事务对此数据进行了访问与修改，此时第一个事务读取的数据结果发生变化。
   4. 幻读
      1. 事务T1读取一条指定的Where子句所返回的结果集，然后T2事务新插入一行记录，然后T1再次对表进行检索，结果集中多了一条数据。（与不可重复读类似，但是单指插入删除，而不是修改）。
5. **事务隔离级别** ：四个级别逐渐减弱，每个级别解决一个问题，事务级别越高，性能越差。
   1. 串行化(Serializable)：所有事务按顺序执行，这样可以避免`幻读`。实现并发控制数据库有两种模式：
      1. 基于锁：执行范围查询的时候，需要获取范围锁。
      2. 不基于锁：检查到违反串行化的操作，需要回滚。
   2. 可重复读(Repeated Read)
      1. 所有被Select获取的数据都不能被修改，可以避免`不可重复读`，但无法控制`幻读`，因为其他事务可以增删数据。
      2. 主流数据库都使用MVCC并发控制，此种数据库在此隔离级别下不会出现幻读现象。
   3. 读已提交(Read Committed)
      1. 被读取的数据可以被其他事务修改，可能导致`不可重复读`。事务读取的时候获得读锁，但是读完后立即释放，而写锁是等事务提交后再释放。
      2. 该等级为SQL Server默认的隔离等级。
   4. 读未提交(Read Uncommited)
      1. 最低的隔离等级，允许其他事务看到没有提交的数据，会导致`脏读`。
      
   | 事务隔离级别                          | 脏读 | 不可重复读 | 幻读 |
   | ------------------------------------- | ---- | ---------- | ---- |
   | Read Uncommited                       | √    | √          | √    |
   | Read Committed - `Sql Server, Oracle` | ×    | √          | √    |
   | Repeatable read - `MySQL`             | ×    | ×          | √    |
   | Serializable                          | ×    | ×          | ×    |
6. **MySQL数据类型**
   1. 整形：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT分别使用8, 16, 32, 64位存储空间。
   2. 浮点数：
      1. FLOAT和DOUBLE为浮点类型，DECIMAL为高精度小数类型。
      2. 不支持DECIMAL类型计算，因此DECIMAL计算比浮点类型需要更高代价。
      3. 三者都可以指定列宽，例如DECIMAL(18, 9)共18位，取9位存储小数部分，剩下9位存储整数部分。
   3. 字符串：
      1. 主要有CHAR和VARCHAR两种类型，一种定长、一种变长。
      2. VARCHAR能够节省空间，因为长度可变，只需要存储必要内容。
   4. 时间和日期：
      1. DATATIME：保存1001年到9999年的日期时间，精度为秒，使用8字节的存储空间。
      2. TIMESTAMP：保存从1970年1月1日午夜以来的秒数，使用4个字节，只能表示1970年至2038年。应该尽量使用，因为TI8MESTAMP比DATATIME的空间效率更高。
7. **索引**
   1. 使用场景
      1. 对于非常小的表，大部分情况全表扫描比建立索引更高效；
      2. 对于中大型表，索引很高效；
      3. 对于特大型表吗，建立和维护索引的代价会随之增长。此情况下需要一种技术可以直接区分出需要查询的一组数据，而不是一条条记录匹配，例如分区技术。
      - 索引是在存储引擎实现的，所以不同存储引擎有不同的索引类型和实现。
   2. B Tree
      1. B Tree原理
            1. 所有叶子节点有相同深度，即B-Tree是平衡的；
            2. 每个叶子节点中包含多个二元组；
            3. 某key的左右相邻key为key_l和key_r，且不为null，则key_r >= key >= key_l。
      2. B+Tree原理
         1. 与B-Tree相比，B+Tree有以下不同点：
            1. 每个节点指针上限为2d而不是2d+1（d为节点的出度）；
            2. 内节点不存储data，只存储key；
            3. 为叶子节点增加了链指针
      3. 为什么使用B/B+树而不使用红黑树等实现索引？
         1. 利用计算机预读特性：每次新建节点直接申请一个页的空间，计算机存储分配都是按页对其的，实现了一个节点只需一次I/O。由于磁盘顺序读取效率很高，因此I/O的耗时主要在遍历不同节点上。
         2. 树高度`h = O(logdN)`（d出度，N节点数量），B/B+树出度很大，因此`h`很小（通常不超过3）。而红黑树这种二叉树结构`h`大得多（需要遍历更多的节点），红黑树I/O渐进复杂度为`O(h)`，效率明显差很多。
      4. 为什么MySQL采用B+树而不是B树实现索引？
         1. B+树更适合外部存储，因为非叶子节点不存储data，因此一个节点可以存储更多的key，每个节点能索引的范围更大更精确。（本质上是单次I/O信息获取量大，因此效率高）。
         2. MySQL是关系型数据库，经常会按照区间访问某个索引列，B+树的叶子节点按顺序建立了链指针，加强了区间访问性。
      5. 附加理解：B/B+树是为了磁盘或其他存储设备而设计的多岔平衡查找树，因此又被称为平衡多路查找树。
   3. 索引分类

      | 特性     | 说明           | InnoDB | MyISAM | MEMORY |
      | -------- | -------------- | ------ | ------ | ------ |
      | B Tree   |                | √      | √      | √      |
      | R Tree   |                |        | √      |        |
      | 哈希索引 | 无法做范围查询 | √      |        | √      |
      | 全文索引 |                | √      | √      |        |

      1. B+Tree索引
         1. 是大多数MySQL存储引擎的默认索引类型。
         2. InnoDB的B+Tree索引分为主索引和辅助索引，辅助索引叶子节点的key-data变为data-key，因此使用辅助索引查找时，需先找到主键值，然后再到主索引中查找。
      2. 空间数据索引(R Tree)
         1. MyISAM存储引擎支持空间数据索引，可以用于地理数据存储。
         2. 会从所有维度来索引数据，可以有效地使用任意维度进行组合查询。
      3. 哈希索引
         1. InnoDB有“自适应哈希索引”。当某个索引值使用非常频繁时，会在B+Tree索引之上再创建一个哈希索引，这样就引入一些哈希的优点，比如快速哈希查找。
         2. 无法用于排序or分组，也无法用于范围查找。
      4. 全文索引
         1. MyISAM引擎支持全文索引，用于查找文本中的关键字（包含关系）。
         2. InnoDB存储引擎在MySQL 5.6.4版本后也支持全文索引。
   4. 索引特点
      1. 优点：
         1. 保证数据库每行数据的唯一性；
         2. 大大加快数据索引、分组、排序速度（主要优点）；
         3. 加快数据库表间连接；
      2. 缺点：
         1. 创建和维护索引需要耗费时间，并随数据量增加而增加；
         2. 索引需要占用额外物理空间；
         3. 当增删改表数据时，索引也需要维护，降低维护效率。
   5. 索引失效
      1. MySQL估计全表扫描比索引块，则不使用索引。例如：`elect * from table_name where key>1 and key<90;`
      2. `select * from table_name where key1=’a’ or key2=’b’`，如果`key1`有索引而`key2`没有索引，则`key1`也不会走索引。
      3. 复合索引，如果索引列不是复合索引中的第一部分，则不使用索引（即不符合最左前缀）。例如复合索引`(key1, key2)`，则查询`select * from table_name where key2=’b’`。
      4. 如果like是以%开始的，则该列索引不会被使用。例如`select * from table_name where key1 like ‘%a’`。
      5. 如果列为字符串，则where条件中必须将字符常量值加引号，否则不会使用索引。例如：`select * from table_name where key1=1`；
      6. 如果使用MEMORY/HEAP表，并且where条件中不使用`=`索引列，则不会使用索引。
   6. 联合索引
      1. 定义：多个列上的索引被称为联合索引，又称复合索引。一个复合索引可以使用索引中的一部分，并且只能是最左侧的部分。例如：`key index(a, b, c)`，可以支持`[a], [a, b], [a, b, c]`三种组合查找，但不支持`[b,c]`等查找。
   7. 主键、外键和索引
      |      | 定义                                               | 作用                   | 个数                     |
      | ---- | -------------------------------------------------- | ---------------------- | ------------------------ |
      | 主键 | 唯一标识一条记录，不能重复且不能为空               | 保证数据完整性         | 主键只能有一个           |
      | 外键 | 表的外键是另一表的主键，外键可以有重复，可以为空值 | 用来建立和其他表的联系 | 一个表可有多个外键       |
      | 索引 | 该字段没有重复值，但可以有一个空值                 | 提高查询排序速度       | 一个表可以有多个唯一索引 |
   8. 聚集索引和非聚集索引
      1. 聚集索引：数据行的物理顺序与列值（一般为主键那一列）逻辑顺序相同，一个表中只能拥有一个聚集索引。例如：新华字典的拼音目录，按照A-Z的顺序，B一定在A后面。
      2. 非聚焦索引：索引的逻辑顺序与磁盘上行的物理顺序不同，一个表中可以有多个非聚焦索引。例如：新华字典的偏旁部首目录，和正文中的物理顺序不同。
         1. 二次查询问题：非聚焦索引叶节点仍是索引节点，只是有一个指针指向对应的数据块，如果使用非聚集索引查询而查询列中包含了其他该索引没有覆盖的列，那么还需要二次查询，查询节点上对应的数据行的数据。
      3. 复合索引：建立两列以上的索引，即可查询复活索引里的列数据，而不需要回表二次查询，如`index(col1, col2)`，执行`select col1, col2 from t1 where col1 = '213';`
      4. 总结：
         1. 聚集索引查询效率比非聚集索引高，但如果频繁改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。
         2. 非聚集索引在查询的时候尽量避免二次查询，这样会大幅提升性能。
         3. 不是所有的表都适合建立索引，只有数据量大表才适合，且建立在选择性高的列上性能更好。

8. **分库分表**
   - 数据切分指通过某种特定条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）中，达到分散单台设备负载的效果，即分库分表。
   1. 垂直切分：把单一的表按列分拆成多个表，并分散到不同的数据库主机上。
      1. 优点：
         1. 拆分后业务清晰，拆分规则明确；
         2. 系统间进行整合和扩展容易；
         3. 按照成本、应用等级、应用类型等将表放到不同机器上，便于管理；
         4. 便于实现动静分离、冷热分离的数据库表设计模式；
         5. 数据维护简单；
      2. 缺点：
         1. 部分业务无法关联，只能通过接口方式解决，提高了系统复杂度；
         2. 受每种业务不同限制，存在单库性能瓶颈，不易数据扩展和提升性能；
         3. 事务处理繁杂。
   2. 水平切分：根据表中数据逻辑关系，将同一个表中数据按照某种条件分拆到多台数据库（主机）上。
      1. 优点：
         1. 单库单表数据保持在一定量级，有助于性能提高；
         2. 切分表结构相同，应用层改造少，只需要增加路由规则即可；
         3. 提高了系统的稳定性和负载能力；
      2. 缺点：
         1. 切分后数据分散，很难利用数据库Join操作，跨库Join性能较差；
         2. 拆分规则难以抽象；
         3. 分片事务的一致性难以解决；
         4. 数据扩容难度和维护量极大。
      3. 策略：
         1. 哈希取模：hash(key) % NUM_DB；
         2. 范围：可以是ID范围，也可以是时间范围（例如先写入服务器A，写满了写到服务器B，以此类推）；
         3. 映射表：使用单独的数据库存储映射关系。

9.  **主从复制与读写分离**
   3. 主从复制
      1. 主从复制用来建立一个和主数据库完全一样的数据库环境，称为从数据库，主数据库一般是实施业务数据操作，从数据库常用读取功能。
      2. 优点：
         1. 可以作为备用数据库，当主数据库出现故障后，从数据库可以替代主数据库继续工作；
         2. 读写分离，将读和写应用在不同的数据库和服务器上，充分利用服务器性能和数据库性能。
      3. 涉及线程：
         1. binlog线程：负责将主服务器上数据更改写入二进制文件中。
         2. I/O线程：负责从主服务器上读取二进制日志文件，并写入从服务器中继日志中。
         3. SQL线程：负责读取中继日志并重放其中的SQL语句。
   4. 读写分离
      1. 主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。
      2. 读写分离常用代理方式实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。
      3. MySQL读写分离提高性能的原因是：
         1. 主从服务器分别负责读写，极大程度缓解了锁的争用；
         2. 从服务器可以配置MyISAM引擎，提升查询性能和节约系统开销；
         3. 增加冗余，提高可用性。

10.  **查询性能优化**
     1. 使用Expain分析优化：Explain用来分析SELECT查询语句，开发人员可以通过分析Explain结果来优化查询语句。
         1. select_type: 查询类型，简单查询、联合查询、子查询等；
         2. key: 使用的索引；
         3. rows: 扫描的次数。
     2. 优化数据访问
         1. 减少请求的数据量：
            1.  只返回必要的列
            2. 只返回必要的行
            3. 缓存重复查询的数据
         2. 减少服务器端扫描的行数：
            1. 使用索引来覆盖查询
     3. 重构查询方式
         1. 切分大查询：大查询一次性执行会锁住很多数据、占满整个事务日志、阻塞很多小的但重要的查询；
         2. 分解大连接查询：将大连接查询（JOIN）分解成多个单表查询，然后将结果在应用程序中关联，优点有：
            1. 让缓存更高效。
            2. 单表查询的缓存结果可能会被其他查询用到，从而减少冗余的查询。
            3. 减少锁竞争；
            4. 在应用层链接，容易对数据库拆分，更容易做到高性能和可扩展。

11. **锁类型**
    1. 乐观锁
       1. 总是假设最好的情况，每次拿数据都认为别人不会修改，所以不上锁，但在更新的时候会判断在此期间别人有没有更新这个数据，可以用版本号和CAS算法实现。乐观锁适用于多读的应用类型，可以提高吞吐量。
       2. Java中`java.util.cocurrent.atomic`包下的原子变量类通过CAS实现了乐观锁。
       3. 常见实现方式
          1. 版本号机制
             1. 数据表中加一个数据版本号version字段，表示数据被修改的次数，当被修改version+1，当线程A读取数据值时同时读取version值，在提交更新的时候对比version是否变化，若未变则更新，否则重试更新操作，直到更新成功。
          2. CAS(Compare and swap)算法
             1. 一种有名的无锁算法。在无锁情况下实现多线程间变量同步，在没有线程阻塞的情况下实现变量同步，也称非阻塞同步。CAS算法涉及三个操作数：
                1. 需要读写的内存值V
                2. 进行比较的值A
                3. 拟写入的新值B
             2. 当且仅当V == A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是个自旋操作，即不断重试。
          3. 乐观锁缺点：
             1. ABA问题：若一个变量V初次读到A，有两个线程分别修改了此变量，a->b->a，则CAS操作的判断机制会判断A未被修改过，发生误判。
             2. 循环时间长开销大：自旋CAS若长时间不成功，会给CPU带来很大的执行开销。
             3. 只能保证一个共享变量的原子操作：CAS只对单个共享变量有效，当操作涉及多个共享变量时无效。但从JDK1.5开始，提供了`AtomicReference`类来保证引用对象间的原子性，可以把多个变量放在一个对象里执行CAS操作。
    2. 悲观锁
       1. 总是假设最坏的情况，每次拿数据都认为别人会修改，因此上锁，这样别人想要拿这个数据就会阻塞直到它拿到锁。传统关系型数据库中用到很多，例如行锁、表锁、读锁、写锁，都在做操作之前上锁。
       2. Java中`Synchronized`和`ReentrantLock`等独占锁是悲观锁的实现。
       3. CAS(乐观锁)与Synchronized(悲观锁)使用情景：
          1. CAS适用于多读少写的场景；
          2. Synchronized适用于写操作比较多的场景。
    3. 共享锁（读锁）
       1. 读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据修改（获取数据上的排他锁），直到已释放所有的共享锁。
       2. 如果事务T对数据A加共享锁后，其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据。
       3. 加共享锁后，`update, insert, delete`语句会自动加排他锁。
    4. 排它锁（写锁）
       1. 排他锁是悲观锁的一种实现，若事务1对数据对象A加上X锁，事务1可以读A也可以修改A，其他事务不能再对A加任何锁，直到事务1释放A上的锁。保证了其他事务在事务1释放A上的锁之前不能再读取和修改A。排他锁会阻塞所有排他锁和共享锁。
       2. 读取加共享锁的原因：防止其他线程给数据加排他锁。
       3. 使用方式：在需执行的语句后加`for update`即可。
    5. 行锁
       1. 分为共享锁和排他锁，就是给某一行加上锁。
       2. 行锁都是基于索引的，如果一条SQL语句用不到索引是不会用行级锁的，会用表级锁。
    6. 表锁
       1. Innodb在有索引的情况（通过索引条件检索数据）会用行锁，没有索引的表会锁定全表。
       2. 缺点：由于需要请求大量锁资源，因此速度慢、内存消耗大。
    7. 死锁
       1. 指多个线程在执行过程中，因争夺资源造成的一种互相等待的现象，若无外力作用，程序无法运行下去。
       2. 解除死锁方法：
          1. 第一种
             1. 查询是否锁表 `show OPEN TABLES where In_use > 0;`
             2. 查询进程 `show processlist`
             3. 杀死进程id `kill id`
          2. 第二种
             1. 查看当前事务 `SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;`
             2. 查看锁定的事务 `SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;`
             3. 查看当前等锁的事务 `SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;`
             4. 杀死进程 `kill 进程ID`
       3. 产生死锁的四个必要条件
          1. 互斥条件：一个资源同一时间只能被一个进程使用。
          2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
          3. 不可剥夺条件：进程获得的资源，不能被其他进程剥夺。
          4. 循环等待条件：若干进程之间形成头尾相接的循环等待条件。

#### 第二部分：高性能MySQL实践

1. 抢订单环节一般会有2个问题：
   1. 高并发：比较火热的秒杀在线人数都是100k人起的，对网站架构是大挑战。
   2. 超卖：如何避免买到商品人数不超过商品数量上限，是难题。
2. 解决方案1：将存库MySQL转移到Redis中，所有写操作放到内存中，由于Redis不存在锁故不会出现相互等待，Redis的读写性能也都远高于MySQL，这就解决了高并发问题。通过队列等异步手段，将变化的数据异步写入到DB中。
   1. 优点：解决性能问题；
   2. 缺点：没有解决超卖问题，同时由于异步写入DB，存在某一时刻DB和Redis数据不一致的风险。
3. 解决方案2：引入队列，将所有写DB操作在单队列中排队，完全串行处理。当达到库存阈值时就不在消费队列，并关闭购买功能，解决了超卖问题。
   1. 优点：解决超卖问题；
   2. 缺点：性能受限于队列处理机处理性能和DB写入性能最低的那个，另外多商品同时抢购需要准备多条队列。
4. 解决方案3：将操作变为两段式，先申请后确认。然后利用Redis的原子自增操作，利用Redis的事务特性来发号，保证拿到小于等于库存阈值的号的人都可以成功提交订单。数据异步更新到DB中。
   1. 优点：解决超卖问题，库存读写都在内存中，同时解决性能问题；
   2. 缺点：由于异步写入DB，可能存在数据不一致。