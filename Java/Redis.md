#### 什么是Redis？
- Redis是一个使用C语言编写的开源key-value数据库，和Memcached类似，但支持存储的value类型更多，包括string，list，set，zset（有序集合），hash（哈希）。
- 这些数据都支持push/pop，add/remove以及取交集并集差集等更丰富操作。而且这些操作都是原子性的。在此基础上，Redis支持各种方式排序。
- 与memcached一样，为了保证效率，数据缓存在内存中。但Redis会周期性把更新数据写入磁盘或给修改操作追加记录文件，并在此基础上实现了master-slave（主从同步）。

#### Redis和Memcached区别与比较
1. Redis不仅支持简单key-value数据，同时提供list，set，zset，hash等数据结构存储；Memcached仅支持简单数据类型string。
2. Redis支持数据备份，即master-slave模式的数据备份。
3. Redis支持数据持久化，可以将内存中数据保存在磁盘中，重启时可以再次加载使用；而Memcached把数据全部存在内存中。
4. Redis的速度比Memcached快很多。
5. Redis使用单线程IO复用模型；Memcached是多线程，非阻塞IO复用网络模型。

#### Redis和Memcached的选择策略
- 使用Redis的String类型做的事都可以用Memcached替换，以换取更好的性能。
- 除以上外，优先使用Redis。

#### 使用Redis有哪些好处？
- 速度快：数据在内存中。
- 支持丰富数据类型：支持string，list，set，zset，hash。
- 支持事务：操作原子性。

#### Redis常见数据结构与使用场景
1. **String**
   1. String数据是简单的key-value类型，value其实不仅可以是String，也可以是数字。
   2. 使用场景：
      1. 常规key-value缓存应用；
      2. 常规计数：微博数、粉丝数。
   3. 常用命令：set，get，decr，incr，mget等。
2. **Hash**
   1. Hash是一个string类型的filed和value映射表，hash特别适合存储对象。
   2. 应用场景:比如可以用Hash数据结构来存储用户信息、商品信息等。
   3. 常用命令：hget，hset，hgetall等。
3. **List**
   1. List的实现为一个双向链表，支持反向查找和遍历，更方便操作。
   2. 应用场景：微博关注列表、粉丝列表、最新消息排行等。
   3. 常用命令：lpush，rpush，lpop，rpop，lrange等。
4. **Set**
   1. set对外提供的功能与list类似，不同之处是set可以自动去重。
   2. set提供了判断某个成员是否在set集合内的接口，而list没有。
   3. 应用场景：微博应用中，将一个用户所有关注人存在一个集合中，将所有粉丝存在一个集合中，可以很方便地实现如共同关注等功能。
   4. 常用命令：sadd，spop，smembers，sunion等。
5. **Sorted Set**
   1. 和set相比，sorted set增加一个权重参数score，使集合中元素能够按score有序排列。
   2. 应用场景：直播间在线用户列表、各种礼物排行榜、弹幕消息（具有先后顺序的消息排行榜）等。
   3. 常用命令：zadd，zrange，zrem，zcard等。

#### Redis并发竞争问题如何解决？
1. Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念。
2. Redis多个客户端连接并不存在竞争；但多个Jedis客户端对Redis并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，均是由客户端连接混乱造成。解决方案：
   1. 客户端角度：为保证每个客户端正常有序与Redis通信，将连接池化，同时对客户端读写Redis操作采用内部锁synchronized。
   2. 服务器角度：利用setnx实现锁。

#### Redis回收进程如何工作？Redis回收使用什么算法？
- 引用计数法：当一个对象引用为0时回收。
- LRU算法原理：淘汰最久未使用的对象。
- LRU算法实现：HashMap + Double LinkedList，时间复杂度O(1)。

#### Redis大量数据插入


#### Redis分区
1. 分区的优势：
   1. 利用多台计算机内存和值，允许我们构造更大的数据库；
   2. 通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。
2. 分区的不足：
   1. 涉及多个key的操作通常不被支持。当两个set映射到不同的redis实例上时，不能对这两个set执行交集操作。
   2. 设计多个key的Redis事务不能使用。
3. 分区类型：
   1. 范围分区：最简单的方式，映射一定范围内的对象到特定的Redis实例。例如ID 0-9999保存在R0，ID 10000-19999保存到R1，以此类推；
   2. 哈希分区：取key的hash值并对4取模，转化为0-3数字，就可以将其映射到4个Redis中的一个了。

#### 持久化数据和缓存怎么做扩容？
1. Snashotting（快照，默认方式）：
   1. 将内存中数据以快照方式写入二进制文件中，默认文件名未dump.rdb。我们可以配置redis在n秒内超过m个key被修改就自动快照，例如：
      1. save 900 1 # 900秒内若超过1个key被修改，则发起快照
      2. save 300 10
   2. 快照保存过程：
      1. redis调用fork，有了子进程和父进程；
      2. 父进程继续处理client请求，子进程负责将内存内容写到临时文件。由于os的实时复制机制，父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。因此子进程地址空间内数据时fork时刻时整个数据库快照。
      3. 当子进程将快照写入临时文件后，用临时文件替换原来的快照文件，然后子进程退出。
      4. 每次快照持久化都是将内存数据完整写入磁盘一次，当数据量较大时，写操作比较多，必然会引起大量的磁盘io操作，严重影响性能。
2. AOF方式：
   1. 由于快照方式是在一定间隔时间做一次，因此如果redis意外down掉，会丢失最后一次快照的所有修改。aof持久化方式可以避免以上问题。
   2. redis每收到一个写命令都通过write函数追加到文件中。当redis重启时会通过重新执行文件中保存的写命令，在内存中重建整个数据库的内容。
   3. 由于os在内核中缓存write做的修改，因此可能不是立即写到磁盘上，因此有可能会丢失部分修改。我们可以通过配置文件指定强制os写入到磁盘的时机，有以下三种：
      1. appendfsync always // 收到写命令就立即写入磁盘，最慢，但保证完整持久化；
      2. appendfsync everysec // 每秒写入磁盘一次，折衷方案；
      3. appendfsync no // 完全依赖os，性能最好，持久化没保证。
   4. AOF方式的问题：持久化文件会变得越来越大。例如调用incr test命令100次，文件必须保存全部的100条命令，其实有99条都是多余的。

#### Redis常见性能问题与解决方案
1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。
2. 若数据重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次。
3. 为了主从复制的速度和连接稳定性，Master和Slave最好在一个局域网内。
4. 尽量避免在压力很大的主库上增加从库。

#### Redis与消息队列
1. Redis的设计目标不是用来做队列的，Disque成为Redis的module，即内置的消息队列模块。
2. Redis用的比较多的是做缓存，例如首页缓存、秒杀系统等。